import { objectSpread2 as _objectSpread2 } from './_virtual/_rollupPluginBabelHelpers.js';
import { createRemoteChannel, retain, release } from '@remote-ui/core';

const REMOTE_ID = Symbol.for('RemoteUi::Dom::Id');
const REMOTE_TYPE = Symbol.for('RemoteUi::Dom::Type');
const REMOTE_PROPS = Symbol.for('RemoteUi::Dom::Props');
class DomReceiver {
  constructor({
    bind,
    customElement,
    applyProperty = defaultApplyProperty
  }) {
    this.receive = createRemoteChannel({
      mount: serializedChildren => {
        console.log("mount: " + JSON.stringify(serializedChildren))
        Android.mount(JSON.stringify(serializedChildren))
        const {
          bound,
          children
        } = this;
        const fragment = this.bound ? document.createDocumentFragment() : null;

        if (bound) {
          let child;

          while (child = bound.lastChild) {
            bound.removeChild(child);
          }
        }

        for (const child of serializedChildren) {
          retain(child);
          const node = this.deserialize(child);
          children.push(node);
          fragment === null || fragment === void 0 ? void 0 : fragment.appendChild(node);
        }

        if (bound && fragment) {
          bound.appendChild(fragment);
        }
      },
      insertChild: (id, index, child) => {
        retain(child);
        console.log(`insert: id: ${id}, index: ${index} ${JSON.stringify(child)}`)
        Android.insertChild(JSON.stringify(child));
        const node = this.deserialize(child);

        if (id == null) {
          var _this$bound;

          this.children.splice(index, 0, node);
          (_this$bound = this.bound) === null || _this$bound === void 0 ? void 0 : _this$bound.insertBefore(node, this.bound.childNodes[index]);
        } else {
          const parent = this.nodes.get(id);
          parent.insertBefore(node, parent.childNodes[index]);
        }
      },
      removeChild: (id, index) => {
        // console.log("remote: ${id} ${index}" )
        if (id == null) {
          var _child$parentNode;

          const [child] = this.children.splice(index, 1);
          (_child$parentNode = child.parentNode) === null || _child$parentNode === void 0 ? void 0 : _child$parentNode.removeChild(child);
          this.release(child);
        } else {
          const node = this.nodes.get(id);
          const child = node.childNodes[index];
          node.removeChild(node.childNodes[index]);
          this.release(child);
        }
      },
      updateProps: (id, newProps) => {
        const node = this.nodes.get(id);

        const oldProps = _objectSpread2({}, node[REMOTE_PROPS]);

        retain(newProps);
        Object.assign(node[REMOTE_PROPS], newProps);

        for (const key of Object.keys(newProps)) {
          this.apply({
            type: node[REMOTE_TYPE],
            element: node,
            property: key,
            value: newProps[key]
          });
          release(oldProps[key]);
        }
      },
      updateText: (id, newText) => {
        this.nodes.get(id).textContent = newText;
      }
    });
    this.nodes = new Map();
    this.bound = null;
    this.children = [];
    this.applyProperty = void 0;
    this.resolveCustomElement = void 0;
    this.applyProperty = applyProperty;
    this.resolveCustomElement = normalizeCustomElement(customElement);
    if (bind) this.bind(bind);
  }

  bind(node) {
    // console.log("Bind " )
    // console.log("Bind " + JSON.stringify(node))
    this.unbind();
    this.bound = node;

    for (const child of this.children) {
      node.appendChild(child);
    }
  }

  unbind() {
    // console.log("Unbind " );
    if (this.bound == null) return;
    this.bound = null;

    for (const child of this.children) {
      var _child$parentNode2;

      (_child$parentNode2 = child.parentNode) === null || _child$parentNode2 === void 0 ? void 0 : _child$parentNode2.removeChild(child);
    }
  }

  apply(options) {
    // console.log("Apply ");// + JSON.stringify(options))
    const result = this.applyProperty(options);

    if (result === false) {
      defaultApplyProperty(options);
    }
  }

  release(child) {
    // console.log("Release ");// + JSON.stringify(child))
    this.nodes.delete(child[REMOTE_ID]);
    release(child[REMOTE_PROPS]);

    for (const grandChild of child.childNodes) {
      this.release(grandChild);
    }
  }

  deserialize(serialized) {
    let node;
    // console.log("deserialize " + JSON.stringify(serialized))

    if ('text' in serialized) {
      node = document.createTextNode(serialized.text);
    } else {
      const elementType = this.resolveCustomElement(serialized.type);
      console.log(`call resolve custom element ${elementType}`);
      Android.response(`Android: call resolve custom element ${elementType}`);

      if (elementType == null) {
        throw new Error(`Canâ€™t create component of type ${JSON.stringify(serialized.type)} because it does not map to a custom element.`);
      }

      node = document.createElement(elementType);
      console.log(`type of node ${typeof(node)}`);
      console.log(`keys ${Object.keys(node)}`);

      for (const key of Object.keys(serialized.props)) {
        this.apply({
          type: serialized.type,
          element: node,
          property: key,
          value: serialized.props[key]
        });
      }

      for (const child of serialized.children) {
        const deserialized = this.deserialize(child);
        node.appendChild(deserialized);
      }

      Object.defineProperty(node, REMOTE_PROPS, {
        value: serialized.props,
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(node, REMOTE_TYPE, {
        value: serialized.type,
        writable: false,
        enumerable: false,
        configurable: true
      });
    }

    Object.defineProperty(node, REMOTE_ID, {
      value: serialized.id,
      writable: false,
      enumerable: false,
      configurable: true
    });
    this.nodes.set(serialized.id, node);
    return node;
  }

}

function normalizeCustomElement(customElement) {
  console.log("custom element: " + JSON.stringify(customElement))
  if (typeof customElement === 'function') {
    return customElement;
  }

  if (customElement instanceof Map) {
    return component => customElement.get(component);
  }

  return component => customElement[component];
}

function defaultApplyProperty({
  element,
  property,
  value
}) {
  element[property] = value;
}

export { DomReceiver };
